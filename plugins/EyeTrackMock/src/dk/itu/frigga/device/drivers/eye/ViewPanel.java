/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * ViewPanel.java
 *
 * Created on Apr 2, 2011, 2:45:04 PM
 */
package dk.itu.frigga.device.drivers.eye;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.RenderingHints;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.font.FontRenderContext;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author phylock
 */
public class ViewPanel extends javax.swing.JPanel implements MouseMotionListener, MouseListener {

  private static final int SIZE = 20;
  private static final int HALFSIZE = SIZE / 2;
  private static final int MARGIN = 2;
  private static final int PADDING = 1;
  private static final Color COLOR_NORMAL = new Color(Color.RED.getRed(), Color.RED.getGreen(), Color.RED.getBlue(), 100);
  private static final Color COLOR_SELECTED = new Color(Color.GREEN.getRed(), Color.GREEN.getGreen(), Color.GREEN.getBlue(), 100);
  private static final Color COLOR_OVER = new Color(Color.YELLOW.getRed(), Color.YELLOW.getGreen(), Color.YELLOW.getBlue(), 100);
  private static final Color COLOR_BACKGROUND = new Color(Color.BLACK.getRed(), Color.BLACK.getGreen(), Color.BLACK.getBlue(), 150);
  private BufferedImage image;
  private List<Device> devices;
  private Device current;
  private Device over;

  /** Creates new form ViewPanel */
  public ViewPanel() {
    initComponents();
    devices = new ArrayList<Device>();
    current = null;
    over = null;
    this.addMouseListener(this);
    this.addMouseMotionListener(this);
  }

  public BufferedImage getImage() {
    return image;
  }

  public void setImage(BufferedImage image) {
    this.image = image;
  }

  public List<Device> getDevices() {
    return devices;
  }

  public void setDevices(List<Device> devices) {
    this.devices = devices;
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 400, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 300, Short.MAX_VALUE)
    );
  }// </editor-fold>//GEN-END:initComponents
  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables

  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    if (image != null) {
      g.drawImage(image, 0, 0, this);

      Graphics2D g2 = (Graphics2D) g;
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
              RenderingHints.VALUE_ANTIALIAS_ON);
      FontRenderContext frc = g2.getFontRenderContext();
      Font font = g2.getFont().deriveFont(16f);
      g2.setFont(font);


      for (Device d : devices) {
        switch (d.getType()) {
          case Point:
            drawPoint(g, d, d.getPoints().get(0), font, frc);
            break;
          case Area:
            drawArea(g, d, d.getPoints(), font, frc);
            break;
        }
      }
    }
  }

  private void drawArea(Graphics g, Device device, List<Point> points, Font font, FontRenderContext frc) {

    int x = points.get(0).getX() - HALFSIZE;
    int y = points.get(0).getY() - HALFSIZE;

    int text_width = (int) font.getStringBounds(device.getLookat(), frc).getWidth();
    int text_height = (int) font.getLineMetrics(device.getLookat(), frc).getHeight();

    int text_x;
    int text_y = y;
    if (text_width + x < 640) {
      text_x = x + (SIZE + (2 * MARGIN) + (2 * PADDING));
    } else {
      text_x = x - (text_width + (2 * MARGIN) + (2 * PADDING));
    }
    boolean show_text = false;

    if (device.equals(current)) {
      g.setColor(COLOR_SELECTED);
      show_text = true;
    } else if (device.equals(over)) {
      g.setColor(COLOR_OVER);
      show_text = true;
    } else {
      g.setColor(COLOR_NORMAL);
    }

    //Button
    int size = points.size();
    int[] px = new int[size];
    int[] py = new int[size];
    for (int i = 0; i < size; i++) {
      px[i] = points.get(i).getX();
      py[i] = points.get(i).getY();
    }

    g.fillPolygon(px, py, size);

    if (show_text) {
      paintLabel(g, device.getLookat(), text_x, text_y, text_width, text_height);
    }

  }

  private void drawPoint(Graphics g, Device device, Point point, Font font, FontRenderContext frc) {

    int x = point.getX() - HALFSIZE;
    int y = point.getY() - HALFSIZE;

    int text_width = (int) font.getStringBounds(device.getLookat(), frc).getWidth();
    int text_height = (int) font.getLineMetrics(device.getLookat(), frc).getHeight();

    int text_x;
    int text_y = y;
    if (text_width + x < 640) {
      text_x = x + (SIZE + (2 * MARGIN) + (2 * PADDING));
    } else {
      text_x = x - (text_width + (2 * MARGIN) + (2 * PADDING));
    }
    boolean show_text = false;

    if (device.equals(current)) {
      g.setColor(COLOR_SELECTED);
      show_text = true;
    } else if (device.equals(over)) {
      g.setColor(COLOR_OVER);
      show_text = true;
    } else {
      g.setColor(COLOR_NORMAL);
    }

    //Button
    g.fill3DRect(x, y, SIZE, SIZE, true);

    if (show_text) {
      paintLabel(g, device.getLookat(), text_x, text_y, text_width, text_height);
    }

  }

  private void paintLabel(Graphics g, String label, int x, int y, int width, int height) {
    g.setColor(COLOR_BACKGROUND);
    g.fillRect(x, y, width + (2 * MARGIN), height + (2 * MARGIN));

    g.setColor(Color.WHITE);
    g.drawString(label, x, y + height);
  }

  public void mouseDragged(MouseEvent e) {
  }

  public void mouseMoved(MouseEvent e) {
    Device d = isOver(e.getX(), e.getY());
    boolean repaint = false;
    if (d == null && over != null) {
      repaint = true;
    } else if (over == null && d != null) {
      repaint = true;
    } else if (d != null && !d.equals(over)) {
      repaint = true;
    }

    over = d;
    if (repaint) {
      repaint();
    }

  }

  public void mouseClicked(MouseEvent e) {
    Device d = isOver(e.getX(), e.getY());
    boolean repaint = false;
    if (d == null && current != null) {
      repaint = true;
    } else if (current == null && d != null) {
      repaint = true;
    } else if (d != null && !d.equals(current)) {
      repaint = true;
    }

    current = d;

    if (repaint) {
      repaint();
    }
  }

  public void mousePressed(MouseEvent e) {
  }

  public void mouseReleased(MouseEvent e) {
  }

  public void mouseEntered(MouseEvent e) {
  }

  public void mouseExited(MouseEvent e) {
  }

  private Device isOver(int x, int y) {
    for (Device d : devices) {
      switch (d.getType()) {
        case Point:

          Point p = d.getPoints().get(0);
          int dx = Math.abs(x - p.getX());
          int dy = Math.abs(y - p.getY());

          if (dx <= HALFSIZE && dy <= HALFSIZE) {
            return d;
          } else if (d.equals(over)) {
            return null;
          }
          break;
        case Area:
          //TODO: this is called many times optimize :d
          Polygon poly = new Polygon();
          for(Point point: d.getPoints())
          {
            poly.addPoint(point.getX(), point.getY());
          }
          if(poly.contains(x, y))
          {
            return d;
          }
          
      }
    }
    return null;
  }

}
