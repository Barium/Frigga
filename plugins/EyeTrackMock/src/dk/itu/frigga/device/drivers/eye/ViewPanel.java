/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * ViewPanel.java
 *
 * Created on Apr 2, 2011, 2:45:04 PM
 */
package dk.itu.frigga.device.drivers.eye;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.font.FontRenderContext;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author phylock
 */
public class ViewPanel extends javax.swing.JPanel implements MouseMotionListener, MouseListener {

  private static final int SIZE = 20;
  private static final int HALFSIZE = SIZE / 2;
  private static final int MARGIN = 2;
  private static final int PADDING = 1;
  private static final Color color_normal = new Color(Color.RED.getRed(), Color.RED.getGreen(), Color.RED.getBlue(), 100);
  private static final Color color_selected = new Color(Color.GREEN.getRed(), Color.GREEN.getGreen(), Color.GREEN.getBlue(), 100);
  private static final Color color_over = new Color(Color.YELLOW.getRed(), Color.YELLOW.getGreen(), Color.YELLOW.getBlue(), 100);
  private static final Color color_background = new Color(Color.BLACK.getRed(), Color.BLACK.getGreen(), Color.BLACK.getBlue(), 150);
  private BufferedImage image;
  private List<Point> points;
  private Point current;
  private Point over;

  /** Creates new form ViewPanel */
  public ViewPanel() {
    initComponents();
    points = new ArrayList<Point>();
    current = null;
    over = null;
    this.addMouseListener(this);
    this.addMouseMotionListener(this);
  }

  public BufferedImage getImage() {
    return image;
  }

  public void setImage(BufferedImage image) {
    this.image = image;
  }

  public List<Point> getPoints() {
    return points;
  }

  public void setPoints(List<Point> points) {
    this.points = points;
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 400, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 300, Short.MAX_VALUE)
    );
  }// </editor-fold>//GEN-END:initComponents
  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables

  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);
    if (image != null) {
      g.drawImage(image, 0, 0, this);

      Graphics2D g2 = (Graphics2D) g;
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
              RenderingHints.VALUE_ANTIALIAS_ON);
      FontRenderContext frc = g2.getFontRenderContext();
      Font font = g2.getFont().deriveFont(16f);
      g2.setFont(font);


      for (Point p : points) {
        int x = p.getX() - HALFSIZE;
        int y = p.getY() - HALFSIZE;

        int text_width = (int) font.getStringBounds(p.getLookat(), frc).getWidth();
        int text_height = (int) font.getLineMetrics(p.getLookat(), frc).getHeight();

        int text_x;
        int text_y = y;
        if (text_width + x < 640) {
          text_x = x + (SIZE + (2 * MARGIN) + (2 * PADDING));
        } else {
          text_x = x - (text_width + (2 * MARGIN) + (2 * PADDING));
        }
        boolean show_text = false;

        if (p.equals(current)) {
          g.setColor(color_selected);
          show_text = true;
        } else if (p.equals(over)) {
          g.setColor(color_over);
          show_text = true;
        } else {
          g.setColor(color_normal);
        }

        //Button
        g.fill3DRect(x, y, SIZE, SIZE, true);

        if (show_text) {
          g.setColor(color_background);
          g2.fillRect(text_x, y, text_width + (2 * MARGIN), text_height + (2 * MARGIN));

          g.setColor(Color.WHITE);
          g.drawString(p.getLookat(), text_x, y + text_height);
        }
      }
    }
  }

  public void mouseDragged(MouseEvent e) {
  }

  public void mouseMoved(MouseEvent e) {
    Point p = isOver(e.getX(), e.getY());
    boolean repaint = false;
    if (p == null && over != null) {
      repaint = true;
    } else if (over == null && p != null) {
      repaint = true;
    } else if (p != null && !p.equals(over)) {
      repaint = true;
    }

    over = p;
    if (repaint) {
      repaint();
    }

  }

  public void mouseClicked(MouseEvent e) {
    Point p = isOver(e.getX(), e.getY());
    boolean repaint = false;
    if (p == null && current != null) {
      repaint = true;
    } else if (current == null && p != null) {
      repaint = true;
    } else if (p != null && !p.equals(current)) {
      repaint = true;
    }

    current = p;

    if (repaint) {
      repaint();
    }
  }

  public void mousePressed(MouseEvent e) {
  }

  public void mouseReleased(MouseEvent e) {
  }

  public void mouseEntered(MouseEvent e) {
  }

  public void mouseExited(MouseEvent e) {
  }

  private Point isOver(int x, int y) {
    for (Point p : points) {
      int dx = Math.abs(x - p.getX());
      int dy = Math.abs(y - p.getY());

      if (dx <= HALFSIZE && dy <= HALFSIZE) {
        return p;
      } else if (p.equals(over)) {
        return null;
      }
    }
    return null;
  }
}
